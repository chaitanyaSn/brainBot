const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash-exp",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
  };
  

   export const courseOutline = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Genrate a study material for\njava for interview prepration the level of\ndifficulty will be medium with summary of course.\nList of chapter along with summary.All result in JSON format"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"courseTitle\": \"Java Interview Preparation: Medium Difficulty\",\n  \"courseSummary\": \"This study material is designed to help candidates prepare for medium-difficulty Java interviews. It covers core Java concepts, including object-oriented programming principles, data structures, algorithms, and common libraries, with a focus on practical application and problem-solving. The material also touches upon multi-threading, exception handling, and best practices, equipping you with the necessary knowledge for a successful interview.\",\n  \"chapters\": [\n    {\n      \"chapterNumber\": 1,\n      \"chapterTitle\": \"Object-Oriented Programming (OOP) Concepts\",\n      \"summary\": \"This chapter covers fundamental OOP concepts in Java: Encapsulation, Inheritance, Polymorphism, and Abstraction. Understanding these principles is crucial for designing robust and maintainable code. We'll delve into practical examples and scenarios to demonstrate their usage and impact.\",\n       \"topics\": [\n          \"Encapsulation: Access Modifiers (public, private, protected, default), getters/setters\",\n          \"Inheritance: Single, Multilevel, Hierarchical, IS-A relationships, method overriding\",\n          \"Polymorphism: Method overloading, method overriding, dynamic method dispatch\",\n          \"Abstraction: Abstract classes, interfaces, achieving abstraction\",\n          \"Key differences between abstract class and interface\",\n           \"Practical scenarios and examples illustrating each concept\"\n         ]\n    },\n    {\n      \"chapterNumber\": 2,\n      \"chapterTitle\": \"Data Structures\",\n      \"summary\": \"This chapter explores commonly used data structures in Java, focusing on their implementation, characteristics, and time complexities. We'll cover arrays, linked lists, stacks, queues, hash maps, hash sets, and trees, discussing when to use each one based on the specific problem requirements. Common interview-related problems with data structures are also discussed.\",\n        \"topics\": [\n          \"Arrays: Declaration, initialization, access, and manipulation; time complexities\",\n           \"Linked Lists: Singly, doubly, circular linked list implementations; time complexities for operations\",\n          \"Stacks: LIFO principle, implementations using arrays and linked lists\",\n          \"Queues: FIFO principle, implementations using arrays and linked lists\",\n          \"Hash Maps: Key-value pairs, hashing, collision handling, time complexities\",\n          \"Hash Sets: Uniqueness of elements, hashing, time complexities\",\n          \"Trees: Binary trees, binary search trees (BST), traversal methods (inorder, preorder, postorder); time complexities\",\n          \"Common interview questions related to data structures\"\n        ]\n    },\n    {\n      \"chapterNumber\": 3,\n      \"chapterTitle\": \"Algorithms\",\n      \"summary\": \"This chapter covers common algorithms with an emphasis on searching and sorting techniques. We'll explore linear search, binary search, bubble sort, selection sort, insertion sort, merge sort, and quicksort. We'll analyze their time complexities and discuss their efficiency in different scenarios. Understanding these algorithm concepts is essential for problem-solving in interviews.\",\n      \"topics\": [\n          \"Searching: Linear search, binary search\",\n           \"Sorting: Bubble sort, selection sort, insertion sort, merge sort, quick sort\",\n          \"Time complexity analysis (Big O notation)\",\n          \"Comparison of algorithm performance based on time complexity and space complexity\",\n          \"Practical application of algorithms in problem-solving\"\n        ]\n    },\n     {\n      \"chapterNumber\": 4,\n      \"chapterTitle\": \"Exception Handling\",\n      \"summary\": \"This chapter focuses on effective exception handling in Java. We'll discuss checked vs. unchecked exceptions, the try-catch-finally block, and how to create custom exceptions. We'll emphasize the importance of proper exception management for creating robust and reliable applications.\",\n      \"topics\": [\n           \"Checked vs. Unchecked Exceptions: Understanding the difference\",\n           \"try-catch-finally Block: Proper usage and flow\",\n          \"Throwing exceptions using 'throw' keyword\",\n          \"Creating custom exceptions\",\n          \"Best practices for exception handling\",\n           \"Common exception scenarios and how to handle them in a robust manner\"\n        ]\n    },\n    {\n      \"chapterNumber\": 5,\n       \"chapterTitle\": \"Multithreading and Concurrency\",\n      \"summary\": \"This chapter introduces the concepts of multithreading in Java, including creating threads, synchronization, and managing shared resources. We'll discuss thread safety issues, the `synchronized` keyword, and the use of locks. This is a crucial topic for understanding how to build concurrent applications.\",\n        \"topics\": [\n           \"Creating threads using Runnable and Thread class\",\n          \"Thread states and lifecycle\",\n          \"Synchronization: Synchronized keyword and synchronized blocks\",\n          \"Thread safety issues and race conditions\",\n          \"Locks and lock interfaces\",\n          \"Using Java concurrency utilities like ExecutorService and thread pools\",\n          \"Common pitfalls in multithreading and best practices\"\n\n        ]\n    },\n    {\n      \"chapterNumber\": 6,\n      \"chapterTitle\": \"Java Collections Framework\",\n      \"summary\": \"This chapter dives into the Java Collections Framework, covering commonly used interfaces (List, Set, Map) and classes (ArrayList, LinkedList, HashSet, HashMap, TreeMap). We'll discuss their characteristics, appropriate use cases, and performance implications. The chapter will also include a discussion of various collection iterators.\",\n       \"topics\": [\n          \"Introduction to the Java Collections Framework\",\n          \"List interface and implementations (ArrayList, LinkedList)\",\n           \"Set interface and implementations (HashSet, TreeSet)\",\n          \"Map interface and implementations (HashMap, TreeMap)\",\n          \"Iterating over collections (Iterators, enhanced for loop)\",\n          \"Choosing appropriate collection types for specific scenarios\",\n          \"Time and space complexity considerations for different collection operations\"\n        ]\n    },\n     {\n      \"chapterNumber\": 7,\n      \"chapterTitle\": \"Common Java Libraries and Utilities\",\n       \"summary\": \"This chapter explores essential Java libraries and utilities, such as String manipulation (using the String and StringBuilder class), working with dates and times, I/O operations and File handling, and the use of streams. We will also explore the basics of reflection in Java. These libraries are commonly used for developing applications and are crucial for interview questions.\",\n        \"topics\": [\n          \"String class and methods for string manipulation\",\n           \"StringBuilder class for efficient string concatenation\",\n          \"Date and Time API: Working with dates and times\",\n           \"Input/Output streams: Reading from and writing to files\",\n            \"File handling: Creating, deleting, renaming files and directories\",\n           \"Java Streams API: Introduction and common operations\",\n          \"Basics of reflection in Java: Accessing class metadata at runtime\"\n       ]\n    }\n\n  ]\n}\n```"},
          ],
        },
      ],
    });
  
   export const genrateNotes = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Genrate exam material detail content for each chapter,Make sure to include all topic point in the content and give content in the form of HTML format(do not add htmlkl,head,body,title tag)\n\"chapters\": [\n    {\n      \"chapterNumber\": 1,\n      \"chapterTitle\": \"Advanced State Management with Redux\",\n      \"summary\": \"This chapter provides a deep dive into Redux, a popular state management library for React applications. It covers Redux's core concepts such as store, actions, reducers, and middleware. It also emphasizes how to effectively integrate Redux into a complex React application and manage asynchronous operations.\",\n      \"topics\": [\n        \"Introduction to Redux and its purpose\",\n        \"Redux core concepts: Store, Actions, Reducers, Middleware\",\n        \"Setting up Redux with React\",\n        \"Connecting React components to the Redux store using `connect`\",\n        \"Managing synchronous and asynchronous actions with Redux Thunk or Redux Saga\",\n        \"Structuring Redux applications for scalability and maintainability\",\n        \"Advanced reducer patterns and techniques\",\n        \"Testing Redux logic\"\n      ]\n    },"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```html\n<div class=\"chapter\">\n    <h2>Chapter 1: Advanced State Management with Redux</h2>\n    <p><strong>Summary:</strong> This chapter provides a deep dive into Redux, a popular state management library for React applications. It covers Redux's core concepts such as store, actions, reducers, and middleware. It also emphasizes how to effectively integrate Redux into a complex React application and manage asynchronous operations.</p>\n    <h3>Topics:</h3>\n    <ul>\n        <li>\n            <h4>Introduction to Redux and its purpose</h4>\n            <ul>\n                <li>Understanding the limitations of component-level state in large applications.</li>\n                <li>Introduction to Redux as a predictable state container.</li>\n                <li>The benefits of using Redux: predictability, maintainability, and scalability.</li>\n                <li>Use cases for Redux and when it's appropriate to use it.</li>\n            </ul>\n        </li>\n        <li>\n            <h4>Redux core concepts: Store, Actions, Reducers, Middleware</h4>\n            <ul>\n                <li><strong>Store:</strong>\n                    <ul>\n                        <li>Definition of the store as the single source of truth.</li>\n                         <li>How to create a Redux store.</li>\n                        <li>Understanding the store's role in holding the application's state.</li>\n                        <li>The process of subscribing to the store and accessing its state.</li>\n                    </ul>\n                </li>\n                <li><strong>Actions:</strong>\n                    <ul>\n                        <li>Definition of actions as plain JavaScript objects describing what happened.</li>\n                        <li>Action creators as functions returning action objects.</li>\n                        <li>The structure of an action object (type and payload).</li>\n                    </ul>\n                </li>\n                 <li><strong>Reducers:</strong>\n                    <ul>\n                        <li>Definition of reducers as pure functions that specify how state changes.</li>\n                        <li>The principle of immutability in reducers.</li>\n                        <li>Understanding the reducer's role in updating the state based on actions.</li>\n                         <li>Use of switch statements or conditional logic in reducer implementations.</li>\n                    </ul>\n                </li>\n               <li><strong>Middleware:</strong>\n                    <ul>\n                       <li>Definition of middleware as a way to intercept actions before they reach reducers.</li>\n                        <li>Common use cases for middleware, such as logging, API calls, and asynchronous operations.</li>\n                       <li>Understanding how to create and apply middleware in a Redux application.</li>\n                    </ul>\n                </li>\n            </ul>\n        </li>\n        <li>\n            <h4>Setting up Redux with React</h4>\n             <ul>\n               <li>Installation of Redux and React-Redux packages.</li>\n                <li>Wrapping the React application with the `Provider` component.</li>\n                <li>Passing the Redux store to the `Provider`.</li>\n             </ul>\n        </li>\n        <li>\n            <h4>Connecting React components to the Redux store using `connect`</h4>\n            <ul>\n                <li>Understanding the `connect` higher-order component from React-Redux.</li>\n                <li>Mapping state to props using `mapStateToProps`.</li>\n                <li>Mapping dispatch to props using `mapDispatchToProps`.</li>\n                <li>Using `connect` to subscribe components to the Redux store and dispatch actions.</li>\n            </ul>\n        </li>\n        <li>\n            <h4>Managing synchronous and asynchronous actions with Redux Thunk or Redux Saga</h4>\n            <ul>\n                 <li><strong>Redux Thunk:</strong>\n                     <ul>\n                        <li>Introduction to Redux Thunk as a middleware for handling asynchronous actions.</li>\n                        <li>Writing action creators that return functions.</li>\n                        <li>Dispatching asynchronous actions with `dispatch` and promises.</li>\n                    </ul>\n                </li>\n                <li><strong>Redux Saga:</strong>\n                     <ul>\n                        <li>Introduction to Redux Saga as a middleware for managing side effects.</li>\n                        <li>Understanding generators and their role in sagas.</li>\n                        <li>Using `take`, `put`, and other Saga effects to handle asynchronous logic.</li>\n                         <li>Comparing and contrasting Redux Thunk and Redux Saga.</li>\n                    </ul>\n                </li>\n\n            </ul>\n        </li>\n        <li>\n            <h4>Structuring Redux applications for scalability and maintainability</h4>\n             <ul>\n                <li>Organizing code into feature slices or modules.</li>\n                <li>Use of folder structures for actions, reducers, and selectors.</li>\n                <li>Implementing reusable selectors to access state.</li>\n                <li>Strategies for avoiding boilerplate code.</li>\n            </ul>\n        </li>\n         <li>\n            <h4>Advanced reducer patterns and techniques</h4>\n              <ul>\n                <li>Using `combineReducers` to manage multiple reducers.</li>\n                <li>Normalizing state structures for efficiency.</li>\n                <li>Implementing reducer composition for complex state updates.</li>\n                <li>Handling nested state updates immutably.</li>\n            </ul>\n        </li>\n        <li>\n            <h4>Testing Redux logic</h4>\n            <ul>\n                 <li>Writing unit tests for reducers.</li>\n                <li>Testing action creators.</li>\n                <li>Mocking dependencies and middleware for testing purposes.</li>\n                 <li>Using testing libraries like Jest and React Testing Library with Redux.</li>\n            </ul>\n        </li>\n    </ul>\n</div>\n```\n"},
          ],
        },
      ],
    });
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // console.log(result.response.text());
